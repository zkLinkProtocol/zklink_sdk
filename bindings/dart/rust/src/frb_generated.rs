// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -634235047;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__AutoDeleveraging_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    sub_account_nonce: impl CstDecode<u32>,
    contract_prices: impl CstDecode<Vec<ContractPrice>>,
    margin_prices: impl CstDecode<Vec<SpotPriceInfo>>,
    adl_account_id: impl CstDecode<u32>,
    pair_id: impl CstDecode<u16>,
    adl_size: impl CstDecode<String>,
    adl_price: impl CstDecode<String>,
    fee: impl CstDecode<String>,
    fee_token: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AutoDeleveraging_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_sub_account_nonce = sub_account_nonce.cst_decode();
            let api_contract_prices = contract_prices.cst_decode();
            let api_margin_prices = margin_prices.cst_decode();
            let api_adl_account_id = adl_account_id.cst_decode();
            let api_pair_id = pair_id.cst_decode();
            let api_adl_size = adl_size.cst_decode();
            let api_adl_price = adl_price.cst_decode();
            let api_fee = fee.cst_decode();
            let api_fee_token = fee_token.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::AutoDeleveraging::new(
                        api_account_id,
                        api_sub_account_id,
                        api_sub_account_nonce,
                        api_contract_prices,
                        api_margin_prices,
                        api_adl_account_id,
                        api_pair_id,
                        api_adl_size,
                        api_adl_price,
                        api_fee,
                        api_fee_token,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__AutoDeleveraging_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutoDeleveraging>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AutoDeleveraging_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::AutoDeleveraging::sign(
                        &mut *api_that_guard,
                        api_zk_link_signer,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__AutoDeleveraging_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutoDeleveraging>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AutoDeleveraging_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::AutoDeleveraging::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ChangePubKey_get_eth_sign_msg_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>,
    >,
    nonce: impl CstDecode<u32>,
    account_id: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChangePubKey_get_eth_sign_msg",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_account_id = account_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::ChangePubKey::get_eth_sign_msg(
                    &*api_that_guard,
                    api_nonce,
                    api_account_id,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ChangePubKey_new_impl(
    chain_id: impl CstDecode<u8>,
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    new_pubkey_hash: impl CstDecode<String>,
    fee_token: impl CstDecode<u32>,
    fee: impl CstDecode<String>,
    nonce: impl CstDecode<u32>,
    eth_signature: impl CstDecode<Option<String>>,
    ts: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChangePubKey_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_chain_id = chain_id.cst_decode();
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_new_pubkey_hash = new_pubkey_hash.cst_decode();
            let api_fee_token = fee_token.cst_decode();
            let api_fee = fee.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_eth_signature = eth_signature.cst_decode();
            let api_ts = ts.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::ChangePubKey::new(
                        api_chain_id,
                        api_account_id,
                        api_sub_account_id,
                        api_new_pubkey_hash,
                        api_fee_token,
                        api_fee,
                        api_nonce,
                        api_eth_signature,
                        api_ts,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ChangePubKey_set_eth_auth_data_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>,
    >,
    sig: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChangePubKey_set_eth_auth_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_sig = sig.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::ChangePubKey::set_eth_auth_data(&mut *api_that_guard, api_sig)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ChangePubKey_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChangePubKey_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::ChangePubKey::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ChangePubKey_to_eip712_request_payload_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>,
    >,
    chain_id: impl CstDecode<u32>,
    address: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChangePubKey_to_eip712_request_payload",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_chain_id = chain_id.cst_decode();
            let api_address = address.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::ChangePubKey::to_eip712_request_payload(
                        &*api_that_guard,
                        api_chain_id,
                        api_address,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ChangePubKey_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChangePubKey_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::ChangePubKey::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ContractMatching_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    taker: impl CstDecode<Contract>,
    maker: impl CstDecode<Vec<Contract>>,
    fee: impl CstDecode<String>,
    fee_token: impl CstDecode<u16>,
    contract_prices: impl CstDecode<Vec<ContractPrice>>,
    margin_prices: impl CstDecode<Vec<SpotPriceInfo>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ContractMatching_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_taker = taker.cst_decode();
            let api_maker = maker.cst_decode();
            let api_fee = fee.cst_decode();
            let api_fee_token = fee_token.cst_decode();
            let api_contract_prices = contract_prices.cst_decode();
            let api_margin_prices = margin_prices.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::ContractMatching::new(
                        api_account_id,
                        api_sub_account_id,
                        api_taker,
                        api_maker,
                        api_fee,
                        api_fee_token,
                        api_contract_prices,
                        api_margin_prices,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ContractMatching_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractMatching>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ContractMatching_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::ContractMatching::sign(
                        &mut *api_that_guard,
                        api_zk_link_signer,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ContractMatching_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractMatching>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ContractMatching_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::ContractMatching::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ContractPrice_new_impl(
    pair_id: impl CstDecode<u16>,
    market_price: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ContractPrice_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_pair_id = pair_id.cst_decode();
            let api_market_price = market_price.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::ContractPrice::new(api_pair_id, api_market_price)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Contract_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    slot_id: impl CstDecode<u32>,
    nonce: impl CstDecode<u32>,
    pair_id: impl CstDecode<u16>,
    size: impl CstDecode<String>,
    price: impl CstDecode<String>,
    direction: impl CstDecode<bool>,
    maker_fee_rate: impl CstDecode<u8>,
    taker_fee_rate: impl CstDecode<u8>,
    has_subsidy: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Contract_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_slot_id = slot_id.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_pair_id = pair_id.cst_decode();
            let api_size = size.cst_decode();
            let api_price = price.cst_decode();
            let api_direction = direction.cst_decode();
            let api_maker_fee_rate = maker_fee_rate.cst_decode();
            let api_taker_fee_rate = taker_fee_rate.cst_decode();
            let api_has_subsidy = has_subsidy.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Contract::new(
                        api_account_id,
                        api_sub_account_id,
                        api_slot_id,
                        api_nonce,
                        api_pair_id,
                        api_size,
                        api_price,
                        api_direction,
                        api_maker_fee_rate,
                        api_taker_fee_rate,
                        api_has_subsidy,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Contract_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contract>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Contract_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Contract::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Contract_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contract>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Contract_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Contract::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__EthTxOption_new_impl(
    is_support_eip1559: impl CstDecode<bool>,
    to: impl CstDecode<String>,
    nonce: impl CstDecode<Option<f64>>,
    value: impl CstDecode<Option<String>>,
    gas: impl CstDecode<Option<f64>>,
    gas_price: impl CstDecode<Option<String>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EthTxOption_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_is_support_eip1559 = is_support_eip1559.cst_decode();
            let api_to = to.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_value = value.cst_decode();
            let api_gas = gas.cst_decode();
            let api_gas_price = gas_price.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::EthTxOption::new(
                        api_is_support_eip1559,
                        api_to,
                        api_nonce,
                        api_value,
                        api_gas,
                        api_gas_price,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ForcedExit_new_impl(
    to_chain_id: impl CstDecode<u8>,
    initiator_account_id: impl CstDecode<u32>,
    initiator_sub_account_id: impl CstDecode<u8>,
    target_sub_account_id: impl CstDecode<u8>,
    target: impl CstDecode<String>,
    l2_source_token: impl CstDecode<u32>,
    l1_target_token: impl CstDecode<u32>,
    exit_amount: impl CstDecode<String>,
    initiator_nonce: impl CstDecode<u32>,
    withdraw_to_l1: impl CstDecode<bool>,
    ts: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ForcedExit_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_to_chain_id = to_chain_id.cst_decode();
            let api_initiator_account_id = initiator_account_id.cst_decode();
            let api_initiator_sub_account_id = initiator_sub_account_id.cst_decode();
            let api_target_sub_account_id = target_sub_account_id.cst_decode();
            let api_target = target.cst_decode();
            let api_l2_source_token = l2_source_token.cst_decode();
            let api_l1_target_token = l1_target_token.cst_decode();
            let api_exit_amount = exit_amount.cst_decode();
            let api_initiator_nonce = initiator_nonce.cst_decode();
            let api_withdraw_to_l1 = withdraw_to_l1.cst_decode();
            let api_ts = ts.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::ForcedExit::new(
                        api_to_chain_id,
                        api_initiator_account_id,
                        api_initiator_sub_account_id,
                        api_target_sub_account_id,
                        api_target,
                        api_l2_source_token,
                        api_l1_target_token,
                        api_exit_amount,
                        api_initiator_nonce,
                        api_withdraw_to_l1,
                        api_ts,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ForcedExit_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ForcedExit>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ForcedExit_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::ForcedExit::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ForcedExit_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ForcedExit>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ForcedExit_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::ForcedExit::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__FundingInfo_new_impl(
    pair_id: impl CstDecode<u16>,
    price: impl CstDecode<String>,
    funding_rate: impl CstDecode<i16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FundingInfo_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_pair_id = pair_id.cst_decode();
            let api_price = price.cst_decode();
            let api_funding_rate = funding_rate.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::FundingInfo::new(api_pair_id, api_price, api_funding_rate)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Funding_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    sub_account_nonce: impl CstDecode<u32>,
    funding_account_ids: impl CstDecode<Vec<u32>>,
    fee: impl CstDecode<String>,
    fee_token: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Funding_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_sub_account_nonce = sub_account_nonce.cst_decode();
            let api_funding_account_ids = funding_account_ids.cst_decode();
            let api_fee = fee.cst_decode();
            let api_fee_token = fee_token.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Funding::new(
                        api_account_id,
                        api_sub_account_id,
                        api_sub_account_nonce,
                        api_funding_account_ids,
                        api_fee,
                        api_fee_token,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Funding_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Funding>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Funding_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Funding::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Funding_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Funding>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Funding_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Funding::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Liquidation_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    sub_account_nonce: impl CstDecode<u32>,
    contract_prices: impl CstDecode<Vec<ContractPrice>>,
    margin_prices: impl CstDecode<Vec<SpotPriceInfo>>,
    liquidation_account_id: impl CstDecode<u32>,
    fee: impl CstDecode<String>,
    fee_token: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Liquidation_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_sub_account_nonce = sub_account_nonce.cst_decode();
            let api_contract_prices = contract_prices.cst_decode();
            let api_margin_prices = margin_prices.cst_decode();
            let api_liquidation_account_id = liquidation_account_id.cst_decode();
            let api_fee = fee.cst_decode();
            let api_fee_token = fee_token.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Liquidation::new(
                        api_account_id,
                        api_sub_account_id,
                        api_sub_account_nonce,
                        api_contract_prices,
                        api_margin_prices,
                        api_liquidation_account_id,
                        api_fee,
                        api_fee_token,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Liquidation_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Liquidation>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Liquidation_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Liquidation::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Liquidation_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Liquidation>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Liquidation_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Liquidation::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__OrderMatching_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    taker: impl CstDecode<Order>,
    maker: impl CstDecode<Order>,
    fee: impl CstDecode<String>,
    fee_token: impl CstDecode<u32>,
    contract_prices: impl CstDecode<Vec<ContractPrice>>,
    margin_prices: impl CstDecode<Vec<SpotPriceInfo>>,
    expect_base_amount: impl CstDecode<String>,
    expect_quote_amount: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OrderMatching_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_taker = taker.cst_decode();
            let api_maker = maker.cst_decode();
            let api_fee = fee.cst_decode();
            let api_fee_token = fee_token.cst_decode();
            let api_contract_prices = contract_prices.cst_decode();
            let api_margin_prices = margin_prices.cst_decode();
            let api_expect_base_amount = expect_base_amount.cst_decode();
            let api_expect_quote_amount = expect_quote_amount.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::OrderMatching::new(
                        api_account_id,
                        api_sub_account_id,
                        api_taker,
                        api_maker,
                        api_fee,
                        api_fee_token,
                        api_contract_prices,
                        api_margin_prices,
                        api_expect_base_amount,
                        api_expect_quote_amount,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__OrderMatching_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OrderMatching>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OrderMatching_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::OrderMatching::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__OrderMatching_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OrderMatching>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OrderMatching_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::OrderMatching::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Order_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    slot_id: impl CstDecode<u32>,
    nonce: impl CstDecode<u32>,
    base_token_id: impl CstDecode<u32>,
    quote_token_id: impl CstDecode<u32>,
    amount: impl CstDecode<String>,
    price: impl CstDecode<String>,
    is_sell: impl CstDecode<bool>,
    maker_fee_rate: impl CstDecode<u8>,
    taker_fee_rate: impl CstDecode<u8>,
    has_subsidy: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Order_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_slot_id = slot_id.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_base_token_id = base_token_id.cst_decode();
            let api_quote_token_id = quote_token_id.cst_decode();
            let api_amount = amount.cst_decode();
            let api_price = price.cst_decode();
            let api_is_sell = is_sell.cst_decode();
            let api_maker_fee_rate = maker_fee_rate.cst_decode();
            let api_taker_fee_rate = taker_fee_rate.cst_decode();
            let api_has_subsidy = has_subsidy.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Order::new(
                        api_account_id,
                        api_sub_account_id,
                        api_slot_id,
                        api_nonce,
                        api_base_token_id,
                        api_quote_token_id,
                        api_amount,
                        api_price,
                        api_is_sell,
                        api_maker_fee_rate,
                        api_taker_fee_rate,
                        api_has_subsidy,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Order_sign_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Order>>>,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Order_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Order::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Order_to_json_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Order>>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Order_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Order::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Parameter_contract_info_impl(
    pair_id: impl CstDecode<u16>,
    symbol: impl CstDecode<String>,
    initial_margin_rate: impl CstDecode<u16>,
    maintenance_margin_rate: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Parameter_contract_info",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_pair_id = pair_id.cst_decode();
            let api_symbol = symbol.cst_decode();
            let api_initial_margin_rate = initial_margin_rate.cst_decode();
            let api_maintenance_margin_rate = maintenance_margin_rate.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Parameter::contract_info(
                        api_pair_id,
                        api_symbol,
                        api_initial_margin_rate,
                        api_maintenance_margin_rate,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Parameter_fee_account_impl(
    account_id: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Parameter_fee_account",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Parameter::fee_account(api_account_id)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Parameter_funding_infos_impl(
    infos: impl CstDecode<Vec<FundingInfo>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Parameter_funding_infos",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_infos = infos.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Parameter::funding_infos(api_infos)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Parameter_insurance_fund_account_impl(
    account_id: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Parameter_insurance_fund_account",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Parameter::insurance_fund_account(api_account_id)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Parameter_margin_info_impl(
    margin_id: impl CstDecode<u8>,
    symbol: impl CstDecode<Option<String>>,
    token_id: impl CstDecode<u32>,
    ratio: impl CstDecode<u8>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Parameter_margin_info",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_margin_id = margin_id.cst_decode();
            let api_symbol = symbol.cst_decode();
            let api_token_id = token_id.cst_decode();
            let api_ratio = ratio.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Parameter::margin_info(
                        api_margin_id,
                        api_symbol,
                        api_token_id,
                        api_ratio,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_create_signed_contract_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    contract: impl CstDecode<Contract>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_create_signed_contract",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_contract = contract.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Signer::create_signed_contract(&*api_that_guard, api_contract)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_create_signed_order_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    order: impl CstDecode<Order>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_create_signed_order",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_order = order.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Signer::create_signed_order(&*api_that_guard, api_order)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_eth_signer_impl(
    eth_private_key: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_eth_signer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_eth_private_key = eth_private_key.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Signer::eth_signer(api_eth_private_key)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_auto_deleveraging_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<AutoDeleveraging>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_auto_deleveraging",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Signer::sign_auto_deleveraging(&*api_that_guard, api_tx)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_change_pubkey_with_create2data_auth_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<ChangePubKey>,
    creator_address: impl CstDecode<String>,
    salt_arg: impl CstDecode<String>,
    code_hash: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_change_pubkey_with_create2data_auth",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            let api_creator_address = creator_address.cst_decode();
            let api_salt_arg = salt_arg.cst_decode();
            let api_code_hash = code_hash.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_change_pubkey_with_create2data_auth(
                        &*api_that_guard,
                        api_tx,
                        api_creator_address,
                        api_salt_arg,
                        api_code_hash,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_change_pubkey_with_eth_ecdsa_auth_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<ChangePubKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_change_pubkey_with_eth_ecdsa_auth",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_change_pubkey_with_eth_ecdsa_auth(
                        &*api_that_guard,
                        api_tx,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_change_pubkey_with_onchain_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<ChangePubKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_change_pubkey_with_onchain",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_change_pubkey_with_onchain(
                        &*api_that_guard,
                        api_tx,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_contract_matching_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<ContractMatching>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_contract_matching",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Signer::sign_contract_matching(&*api_that_guard, api_tx)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_forced_exit_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<ForcedExit>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_forced_exit",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_forced_exit(&*api_that_guard, api_tx)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_funding_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<Funding>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_funding",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_funding(&*api_that_guard, api_tx)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_liquidation_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<Liquidation>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_liquidation",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_liquidation(&*api_that_guard, api_tx)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_order_matching_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<OrderMatching>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_order_matching",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Signer::sign_order_matching(&*api_that_guard, api_tx)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_transfer_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<Transfer>,
    token_symbol: impl CstDecode<String>,
    chain_id: impl CstDecode<Option<String>>,
    addr: impl CstDecode<Option<String>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_transfer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            let api_token_symbol = token_symbol.cst_decode();
            let api_chain_id = chain_id.cst_decode();
            let api_addr = addr.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_transfer(
                        &*api_that_guard,
                        api_tx,
                        api_token_symbol,
                        api_chain_id,
                        api_addr,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_sign_withdraw_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>,
    tx: impl CstDecode<Withdraw>,
    token_symbol: impl CstDecode<String>,
    chain_id: impl CstDecode<Option<String>>,
    addr: impl CstDecode<Option<String>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_sign_withdraw",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx = tx.cst_decode();
            let api_token_symbol = token_symbol.cst_decode();
            let api_chain_id = chain_id.cst_decode();
            let api_addr = addr.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Signer::sign_withdraw(
                        &*api_that_guard,
                        api_tx,
                        api_token_symbol,
                        api_chain_id,
                        api_addr,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Signer_starknet_signer_impl(
    eth_private_key: impl CstDecode<String>,
    starknet_chain_id: impl CstDecode<String>,
    starknet_addr: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Signer_starknet_signer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_eth_private_key = eth_private_key.cst_decode();
            let api_starknet_chain_id = starknet_chain_id.cst_decode();
            let api_starknet_addr = starknet_addr.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Signer::starknet_signer(
                        api_eth_private_key,
                        api_starknet_chain_id,
                        api_starknet_addr,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__SpotPriceInfo_new_impl(
    token_id: impl CstDecode<u32>,
    price: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpotPriceInfo_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_token_id = token_id.cst_decode();
            let api_price = price.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::SpotPriceInfo::new(api_token_id, api_price)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Transfer_get_eth_sign_msg_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>>,
    >,
    token_symbol: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transfer_get_eth_sign_msg",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_token_symbol = token_symbol.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::Transfer::get_eth_sign_msg(
                    &*api_that_guard,
                    api_token_symbol,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__Transfer_new_impl(
    account_id: impl CstDecode<u32>,
    to_address: impl CstDecode<String>,
    from_sub_account_id: impl CstDecode<u8>,
    to_sub_account_id: impl CstDecode<u8>,
    token: impl CstDecode<u32>,
    fee: impl CstDecode<String>,
    amount: impl CstDecode<String>,
    nonce: impl CstDecode<u32>,
    ts: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transfer_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_to_address = to_address.cst_decode();
            let api_from_sub_account_id = from_sub_account_id.cst_decode();
            let api_to_sub_account_id = to_sub_account_id.cst_decode();
            let api_token = token.cst_decode();
            let api_fee = fee.cst_decode();
            let api_amount = amount.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_ts = ts.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Transfer::new(
                        api_account_id,
                        api_to_address,
                        api_from_sub_account_id,
                        api_to_sub_account_id,
                        api_token,
                        api_fee,
                        api_amount,
                        api_nonce,
                        api_ts,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Transfer_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transfer_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Transfer::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Transfer_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transfer_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Transfer::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__UpdateGlobalVar_new_impl(
    from_chain_id: impl CstDecode<u8>,
    sub_account_id: impl CstDecode<u8>,
    parameter: impl CstDecode<Parameter>,
    serial_id: impl CstDecode<f64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UpdateGlobalVar_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_from_chain_id = from_chain_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_parameter = parameter.cst_decode();
            let api_serial_id = serial_id.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::UpdateGlobalVar::new(
                        api_from_chain_id,
                        api_sub_account_id,
                        api_parameter,
                        api_serial_id,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__UpdateGlobalVar_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UpdateGlobalVar>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UpdateGlobalVar_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::UpdateGlobalVar::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Wallet_approve_erc20_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    contract: impl CstDecode<String>,
    amount: impl CstDecode<String>,
    eth_params: impl CstDecode<EthTxOption>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_approve_erc20",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_contract = contract.cst_decode();
            let api_amount = amount.cst_decode();
            let api_eth_params = eth_params.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::approve_erc20(
                            &*api_that_guard,
                            api_contract,
                            api_amount,
                            api_eth_params,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_deposit_erc20_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    sub_account_id: impl CstDecode<u8>,
    deposit_to: impl CstDecode<String>,
    token_addr: impl CstDecode<String>,
    amount: impl CstDecode<String>,
    mapping: impl CstDecode<bool>,
    eth_params: impl CstDecode<EthTxOption>,
    is_gateway: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_deposit_erc20",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_deposit_to = deposit_to.cst_decode();
            let api_token_addr = token_addr.cst_decode();
            let api_amount = amount.cst_decode();
            let api_mapping = mapping.cst_decode();
            let api_eth_params = eth_params.cst_decode();
            let api_is_gateway = is_gateway.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::deposit_erc20(
                            &*api_that_guard,
                            api_sub_account_id,
                            api_deposit_to,
                            api_token_addr,
                            api_amount,
                            api_mapping,
                            api_eth_params,
                            api_is_gateway,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_deposit_eth_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    sub_account_id: impl CstDecode<u8>,
    deposit_to: impl CstDecode<String>,
    eth_params: impl CstDecode<EthTxOption>,
    is_gateway: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_deposit_eth",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_deposit_to = deposit_to.cst_decode();
            let api_eth_params = eth_params.cst_decode();
            let api_is_gateway = is_gateway.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::deposit_eth(
                            &*api_that_guard,
                            api_sub_account_id,
                            api_deposit_to,
                            api_eth_params,
                            api_is_gateway,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_full_exit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    token_id: impl CstDecode<u16>,
    mapping: impl CstDecode<bool>,
    eth_params: impl CstDecode<EthTxOption>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_full_exit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_token_id = token_id.cst_decode();
            let api_mapping = mapping.cst_decode();
            let api_eth_params = eth_params.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::full_exit(
                            &*api_that_guard,
                            api_account_id,
                            api_sub_account_id,
                            api_token_id,
                            api_mapping,
                            api_eth_params,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::get_balance(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_get_deposit_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    eth_params: impl CstDecode<EthTxOption>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_get_deposit_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_eth_params = eth_params.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::Wallet::get_deposit_fee(&*api_that_guard, api_eth_params)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_get_nonce_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    block_number: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_get_nonce",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_block_number = block_number.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::Wallet::get_nonce(&*api_that_guard, api_block_number)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_new_impl(
    url: impl CstDecode<String>,
    private_key: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_url = url.cst_decode();
            let api_private_key = private_key.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Wallet::new(api_url, api_private_key)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Wallet_set_auth_pubkey_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    nonce: impl CstDecode<f64>,
    new_pubkey_hash: impl CstDecode<String>,
    eth_params: impl CstDecode<EthTxOption>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_set_auth_pubkey_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_new_pubkey_hash = new_pubkey_hash.cst_decode();
            let api_eth_params = eth_params.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::set_auth_pubkey_hash(
                            &*api_that_guard,
                            api_nonce,
                            api_new_pubkey_hash,
                            api_eth_params,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Wallet_wait_for_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>,
    tx_hash: impl CstDecode<String>,
    timeout: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Wallet_wait_for_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_tx_hash = tx_hash.cst_decode();
            let api_timeout = timeout.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::Wallet::wait_for_transaction(
                            &*api_that_guard,
                            api_tx_hash,
                            api_timeout,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__Withdraw_get_eth_sign_msg_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>>,
    >,
    token_symbol: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Withdraw_get_eth_sign_msg",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_token_symbol = token_symbol.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::Withdraw::get_eth_sign_msg(
                    &*api_that_guard,
                    api_token_symbol,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__Withdraw_new_impl(
    account_id: impl CstDecode<u32>,
    sub_account_id: impl CstDecode<u8>,
    to_chain_id: impl CstDecode<u8>,
    to_address: impl CstDecode<String>,
    l2_source_token: impl CstDecode<u32>,
    l1_target_token: impl CstDecode<u32>,
    amount: impl CstDecode<String>,
    call_data: impl CstDecode<Option<String>>,
    fee: impl CstDecode<String>,
    nonce: impl CstDecode<u32>,
    withdraw_to_l1: impl CstDecode<bool>,
    withdraw_fee_ratio: impl CstDecode<u16>,
    ts: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Withdraw_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_account_id = account_id.cst_decode();
            let api_sub_account_id = sub_account_id.cst_decode();
            let api_to_chain_id = to_chain_id.cst_decode();
            let api_to_address = to_address.cst_decode();
            let api_l2_source_token = l2_source_token.cst_decode();
            let api_l1_target_token = l1_target_token.cst_decode();
            let api_amount = amount.cst_decode();
            let api_call_data = call_data.cst_decode();
            let api_fee = fee.cst_decode();
            let api_nonce = nonce.cst_decode();
            let api_withdraw_to_l1 = withdraw_to_l1.cst_decode();
            let api_withdraw_fee_ratio = withdraw_fee_ratio.cst_decode();
            let api_ts = ts.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::Withdraw::new(
                        api_account_id,
                        api_sub_account_id,
                        api_to_chain_id,
                        api_to_address,
                        api_l2_source_token,
                        api_l1_target_token,
                        api_amount,
                        api_call_data,
                        api_fee,
                        api_nonce,
                        api_withdraw_to_l1,
                        api_withdraw_fee_ratio,
                        api_ts,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Withdraw_sign_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>>,
    >,
    zk_link_signer: impl CstDecode<ZkLinkSigner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Withdraw_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_zk_link_signer = zk_link_signer.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::Withdraw::sign(&mut *api_that_guard, api_zk_link_signer)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__Withdraw_to_json_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Withdraw_to_json",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::Withdraw::to_json(&*api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ZkLinkSignature_get_pubkey_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSignature>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSignature_get_pubkey",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::ZkLinkSignature::get_pubkey(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ZkLinkSignature_get_signature_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSignature>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSignature_get_signature",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::ZkLinkSignature::get_signature(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ZkLinkSigner_eth_sig_impl(
    sig: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSigner_eth_sig",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_sig = sig.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::ZkLinkSigner::eth_sig(api_sig)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ZkLinkSigner_get_pubkey_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSigner_get_pubkey",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::ZkLinkSigner::get_pubkey(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ZkLinkSigner_get_pubkey_hash_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSigner_get_pubkey_hash",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::ZkLinkSigner::get_pubkey_hash(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ZkLinkSigner_sign_musig_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>>,
    >,
    msg: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSigner_sign_musig",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::ZkLinkSigner::sign_musig(&*api_that_guard, api_msg)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__ZkLinkSigner_starknet_sig_impl(
    sig: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ZkLinkSigner_starknet_sig",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_sig = sig.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::ZkLinkSigner::starknet_sig(api_sig)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__closest_packable_fee_amount_impl(
    fee: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "closest_packable_fee_amount",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_fee = fee.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::closest_packable_fee_amount(api_fee)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__closest_packable_token_amount_impl(
    amount: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "closest_packable_token_amount",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_amount = amount.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::closest_packable_token_amount(api_amount)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__init_app_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__is_fee_amount_packable_impl(
    fee: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_fee_amount_packable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_fee = fee.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::is_fee_amount_packable(api_fee)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__is_token_amount_packable_impl(
    amount: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_token_amount_packable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_amount = amount.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::is_token_amount_packable(api_amount)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i16> for i16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i16 {
        self
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for AutoDeleveraging {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutoDeleveraging>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChangePubKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Contract {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contract>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ContractMatching {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractMatching>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ContractPrice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractPrice>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EthTxOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EthTxOption>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ForcedExit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ForcedExit>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Funding {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Funding>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FundingInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FundingInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Liquidation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Liquidation>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Order {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Order>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OrderMatching {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OrderMatching>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Parameter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Parameter>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Signer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SpotPriceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpotPriceInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Transfer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for UpdateGlobalVar {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UpdateGlobalVar>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Wallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Withdraw {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ZkLinkSignature {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSignature>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ZkLinkSigner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutoDeleveraging>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contract>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractMatching>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractPrice>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EthTxOption>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ForcedExit>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Funding>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FundingInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Liquidation>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Order>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OrderMatching>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Parameter>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpotPriceInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UpdateGlobalVar>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSignature>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<Contract> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Contract>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ContractPrice> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ContractPrice>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FundingInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FundingInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<SpotPriceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<SpotPriceInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AutoDeleveraging> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AutoDeleveraging> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AutoDeleveraging>> for AutoDeleveraging {
    fn into_into_dart(self) -> FrbWrapper<AutoDeleveraging> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChangePubKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChangePubKey> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChangePubKey>> for ChangePubKey {
    fn into_into_dart(self) -> FrbWrapper<ChangePubKey> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Contract> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Contract> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Contract>> for Contract {
    fn into_into_dart(self) -> FrbWrapper<Contract> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ContractMatching> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ContractMatching> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ContractMatching>> for ContractMatching {
    fn into_into_dart(self) -> FrbWrapper<ContractMatching> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ContractPrice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ContractPrice> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ContractPrice>> for ContractPrice {
    fn into_into_dart(self) -> FrbWrapper<ContractPrice> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EthTxOption> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EthTxOption> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EthTxOption>> for EthTxOption {
    fn into_into_dart(self) -> FrbWrapper<EthTxOption> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ForcedExit> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ForcedExit> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ForcedExit>> for ForcedExit {
    fn into_into_dart(self) -> FrbWrapper<ForcedExit> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Funding> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Funding> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Funding>> for Funding {
    fn into_into_dart(self) -> FrbWrapper<Funding> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FundingInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FundingInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FundingInfo>> for FundingInfo {
    fn into_into_dart(self) -> FrbWrapper<FundingInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Liquidation> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Liquidation> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Liquidation>> for Liquidation {
    fn into_into_dart(self) -> FrbWrapper<Liquidation> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Order> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Order> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Order>> for Order {
    fn into_into_dart(self) -> FrbWrapper<Order> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OrderMatching> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OrderMatching> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OrderMatching>> for OrderMatching {
    fn into_into_dart(self) -> FrbWrapper<OrderMatching> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Parameter> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Parameter> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Parameter>> for Parameter {
    fn into_into_dart(self) -> FrbWrapper<Parameter> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Signer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Signer> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Signer>> for Signer {
    fn into_into_dart(self) -> FrbWrapper<Signer> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SpotPriceInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SpotPriceInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SpotPriceInfo>> for SpotPriceInfo {
    fn into_into_dart(self) -> FrbWrapper<SpotPriceInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Transfer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Transfer> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Transfer>> for Transfer {
    fn into_into_dart(self) -> FrbWrapper<Transfer> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<UpdateGlobalVar> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<UpdateGlobalVar> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<UpdateGlobalVar>> for UpdateGlobalVar {
    fn into_into_dart(self) -> FrbWrapper<UpdateGlobalVar> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Wallet> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Wallet> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Wallet>> for Wallet {
    fn into_into_dart(self) -> FrbWrapper<Wallet> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Withdraw> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Withdraw> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Withdraw>> for Withdraw {
    fn into_into_dart(self) -> FrbWrapper<Withdraw> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ZkLinkSignature> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ZkLinkSignature> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ZkLinkSignature>> for ZkLinkSignature {
    fn into_into_dart(self) -> FrbWrapper<ZkLinkSignature> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ZkLinkSigner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ZkLinkSigner> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ZkLinkSigner>> for ZkLinkSigner {
    fn into_into_dart(self) -> FrbWrapper<ZkLinkSigner> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for AutoDeleveraging {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutoDeleveraging>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChangePubKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Contract {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contract>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ContractMatching {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractMatching>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ContractPrice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractPrice>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for EthTxOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EthTxOption>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ForcedExit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ForcedExit>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Funding {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Funding>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for FundingInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FundingInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Liquidation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Liquidation>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Order {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Order>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for OrderMatching {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OrderMatching>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Parameter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Parameter>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Signer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SpotPriceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpotPriceInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Transfer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for UpdateGlobalVar {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UpdateGlobalVar>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Wallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Withdraw {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ZkLinkSignature {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSignature>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ZkLinkSigner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutoDeleveraging>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChangePubKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contract>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractMatching>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContractPrice>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EthTxOption>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ForcedExit>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Funding>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FundingInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Liquidation>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Order>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OrderMatching>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Parameter>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signer>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpotPriceInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transfer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UpdateGlobalVar>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Wallet>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Withdraw>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSignature>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ZkLinkSigner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<Contract> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Contract>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ContractPrice> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ContractPrice>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FundingInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FundingInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<SpotPriceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <SpotPriceInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;
