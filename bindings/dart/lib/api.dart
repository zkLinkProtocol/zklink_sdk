// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.32.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

bool isTokenAmountPackable({required String amount, dynamic hint}) =>
    RustLib.instance.api.isTokenAmountPackable(amount: amount, hint: hint);

bool isFeeAmountPackable({required String fee, dynamic hint}) =>
    RustLib.instance.api.isFeeAmountPackable(fee: fee, hint: hint);

String closestPackableTokenAmount({required String amount, dynamic hint}) =>
    RustLib.instance.api.closestPackableTokenAmount(amount: amount, hint: hint);

String closestPackableFeeAmount({required String fee, dynamic hint}) =>
    RustLib.instance.api.closestPackableFeeAmount(fee: fee, hint: hint);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<AutoDeleveraging>>
@sealed
class AutoDeleveraging extends RustOpaque {
  AutoDeleveraging.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AutoDeleveraging.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AutoDeleveraging,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AutoDeleveraging,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AutoDeleveragingPtr,
  );

  factory AutoDeleveraging(
          {required int accountId,
          required int subAccountId,
          required int subAccountNonce,
          required List<ContractPrice> contractPrices,
          required List<SpotPriceInfo> marginPrices,
          required int adlAccountId,
          required int pairId,
          required String adlSize,
          required String adlPrice,
          required String fee,
          required int feeToken,
          dynamic hint}) =>
      RustLib.instance.api.autoDeleveragingNew(
          accountId: accountId,
          subAccountId: subAccountId,
          subAccountNonce: subAccountNonce,
          contractPrices: contractPrices,
          marginPrices: marginPrices,
          adlAccountId: adlAccountId,
          pairId: pairId,
          adlSize: adlSize,
          adlPrice: adlPrice,
          fee: fee,
          feeToken: feeToken,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) => RustLib
      .instance.api
      .autoDeleveragingSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.autoDeleveragingToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<ChangePubKey>>
@sealed
class ChangePubKey extends RustOpaque {
  ChangePubKey.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ChangePubKey.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ChangePubKey,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ChangePubKey,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ChangePubKeyPtr,
  );

  String getEthSignMsg(
          {required int nonce, required int accountId, dynamic hint}) =>
      RustLib.instance.api.changePubKeyGetEthSignMsg(
          that: this, nonce: nonce, accountId: accountId, hint: hint);

  factory ChangePubKey(
          {required int chainId,
          required int accountId,
          required int subAccountId,
          required String newPubkeyHash,
          required int feeToken,
          required String fee,
          required int nonce,
          String? ethSignature,
          int? ts,
          dynamic hint}) =>
      RustLib.instance.api.changePubKeyNew(
          chainId: chainId,
          accountId: accountId,
          subAccountId: subAccountId,
          newPubkeyHash: newPubkeyHash,
          feeToken: feeToken,
          fee: fee,
          nonce: nonce,
          ethSignature: ethSignature,
          ts: ts,
          hint: hint);

  void setEthAuthData({required String sig, dynamic hint}) =>
      RustLib.instance.api
          .changePubKeySetEthAuthData(that: this, sig: sig, hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .changePubKeySign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toEip712RequestPayload(
          {required int chainId, required String address, dynamic hint}) =>
      RustLib.instance.api.changePubKeyToEip712RequestPayload(
          that: this, chainId: chainId, address: address, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.changePubKeyToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Contract>>
@sealed
class Contract extends RustOpaque {
  Contract.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Contract.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Contract,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Contract,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ContractPtr,
  );

  factory Contract(
          {required int accountId,
          required int subAccountId,
          required int slotId,
          required int nonce,
          required int pairId,
          required String size,
          required String price,
          required bool direction,
          required int makerFeeRate,
          required int takerFeeRate,
          required bool hasSubsidy,
          dynamic hint}) =>
      RustLib.instance.api.contractNew(
          accountId: accountId,
          subAccountId: subAccountId,
          slotId: slotId,
          nonce: nonce,
          pairId: pairId,
          size: size,
          price: price,
          direction: direction,
          makerFeeRate: makerFeeRate,
          takerFeeRate: takerFeeRate,
          hasSubsidy: hasSubsidy,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .contractSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.contractToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<ContractMatching>>
@sealed
class ContractMatching extends RustOpaque {
  ContractMatching.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ContractMatching.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ContractMatching,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ContractMatching,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ContractMatchingPtr,
  );

  factory ContractMatching(
          {required int accountId,
          required int subAccountId,
          required Contract taker,
          required List<Contract> maker,
          required String fee,
          required int feeToken,
          required List<ContractPrice> contractPrices,
          required List<SpotPriceInfo> marginPrices,
          dynamic hint}) =>
      RustLib.instance.api.contractMatchingNew(
          accountId: accountId,
          subAccountId: subAccountId,
          taker: taker,
          maker: maker,
          fee: fee,
          feeToken: feeToken,
          contractPrices: contractPrices,
          marginPrices: marginPrices,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) => RustLib
      .instance.api
      .contractMatchingSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.contractMatchingToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<ContractPrice>>
@sealed
class ContractPrice extends RustOpaque {
  ContractPrice.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ContractPrice.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ContractPrice,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ContractPrice,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ContractPricePtr,
  );

  factory ContractPrice(
          {required int pairId, required String marketPrice, dynamic hint}) =>
      RustLib.instance.api.contractPriceNew(
          pairId: pairId, marketPrice: marketPrice, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<EthTxOption>>
@sealed
class EthTxOption extends RustOpaque {
  EthTxOption.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  EthTxOption.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EthTxOption,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EthTxOption,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EthTxOptionPtr,
  );

  factory EthTxOption(
          {required bool isSupportEip1559,
          required String to,
          double? nonce,
          String? value,
          double? gas,
          String? gasPrice,
          dynamic hint}) =>
      RustLib.instance.api.ethTxOptionNew(
          isSupportEip1559: isSupportEip1559,
          to: to,
          nonce: nonce,
          value: value,
          gas: gas,
          gasPrice: gasPrice,
          hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<ForcedExit>>
@sealed
class ForcedExit extends RustOpaque {
  ForcedExit.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ForcedExit.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ForcedExit,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ForcedExit,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ForcedExitPtr,
  );

  factory ForcedExit(
          {required int toChainId,
          required int initiatorAccountId,
          required int initiatorSubAccountId,
          required int targetSubAccountId,
          required String target,
          required int l2SourceToken,
          required int l1TargetToken,
          required String exitAmount,
          required int initiatorNonce,
          required bool withdrawToL1,
          int? ts,
          dynamic hint}) =>
      RustLib.instance.api.forcedExitNew(
          toChainId: toChainId,
          initiatorAccountId: initiatorAccountId,
          initiatorSubAccountId: initiatorSubAccountId,
          targetSubAccountId: targetSubAccountId,
          target: target,
          l2SourceToken: l2SourceToken,
          l1TargetToken: l1TargetToken,
          exitAmount: exitAmount,
          initiatorNonce: initiatorNonce,
          withdrawToL1: withdrawToL1,
          ts: ts,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .forcedExitSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.forcedExitToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Funding>>
@sealed
class Funding extends RustOpaque {
  Funding.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Funding.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Funding,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Funding,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FundingPtr,
  );

  factory Funding(
          {required int accountId,
          required int subAccountId,
          required int subAccountNonce,
          required List<int> fundingAccountIds,
          required String fee,
          required int feeToken,
          dynamic hint}) =>
      RustLib.instance.api.fundingNew(
          accountId: accountId,
          subAccountId: subAccountId,
          subAccountNonce: subAccountNonce,
          fundingAccountIds: fundingAccountIds,
          fee: fee,
          feeToken: feeToken,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .fundingSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.fundingToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<FundingInfo>>
@sealed
class FundingInfo extends RustOpaque {
  FundingInfo.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  FundingInfo.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_FundingInfo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_FundingInfo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FundingInfoPtr,
  );

  factory FundingInfo(
          {required int pairId,
          required String price,
          required int fundingRate,
          dynamic hint}) =>
      RustLib.instance.api.fundingInfoNew(
          pairId: pairId, price: price, fundingRate: fundingRate, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Liquidation>>
@sealed
class Liquidation extends RustOpaque {
  Liquidation.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  Liquidation.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Liquidation,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Liquidation,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_LiquidationPtr,
  );

  factory Liquidation(
          {required int accountId,
          required int subAccountId,
          required int subAccountNonce,
          required List<ContractPrice> contractPrices,
          required List<SpotPriceInfo> marginPrices,
          required int liquidationAccountId,
          required String fee,
          required int feeToken,
          dynamic hint}) =>
      RustLib.instance.api.liquidationNew(
          accountId: accountId,
          subAccountId: subAccountId,
          subAccountNonce: subAccountNonce,
          contractPrices: contractPrices,
          marginPrices: marginPrices,
          liquidationAccountId: liquidationAccountId,
          fee: fee,
          feeToken: feeToken,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .liquidationSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.liquidationToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Order>>
@sealed
class Order extends RustOpaque {
  Order.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Order.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Order,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Order,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OrderPtr,
  );

  factory Order(
          {required int accountId,
          required int subAccountId,
          required int slotId,
          required int nonce,
          required int baseTokenId,
          required int quoteTokenId,
          required String amount,
          required String price,
          required bool isSell,
          required int makerFeeRate,
          required int takerFeeRate,
          required bool hasSubsidy,
          dynamic hint}) =>
      RustLib.instance.api.orderNew(
          accountId: accountId,
          subAccountId: subAccountId,
          slotId: slotId,
          nonce: nonce,
          baseTokenId: baseTokenId,
          quoteTokenId: quoteTokenId,
          amount: amount,
          price: price,
          isSell: isSell,
          makerFeeRate: makerFeeRate,
          takerFeeRate: takerFeeRate,
          hasSubsidy: hasSubsidy,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .orderSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.orderToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<OrderMatching>>
@sealed
class OrderMatching extends RustOpaque {
  OrderMatching.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  OrderMatching.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OrderMatching,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OrderMatching,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OrderMatchingPtr,
  );

  factory OrderMatching(
          {required int accountId,
          required int subAccountId,
          required Order taker,
          required Order maker,
          required String fee,
          required int feeToken,
          required List<ContractPrice> contractPrices,
          required List<SpotPriceInfo> marginPrices,
          required String expectBaseAmount,
          required String expectQuoteAmount,
          dynamic hint}) =>
      RustLib.instance.api.orderMatchingNew(
          accountId: accountId,
          subAccountId: subAccountId,
          taker: taker,
          maker: maker,
          fee: fee,
          feeToken: feeToken,
          contractPrices: contractPrices,
          marginPrices: marginPrices,
          expectBaseAmount: expectBaseAmount,
          expectQuoteAmount: expectQuoteAmount,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) => RustLib
      .instance.api
      .orderMatchingSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.orderMatchingToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Parameter>>
@sealed
class Parameter extends RustOpaque {
  Parameter.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Parameter.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Parameter,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Parameter,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ParameterPtr,
  );

  static Parameter contractInfo(
          {required int pairId,
          required String symbol,
          required int initialMarginRate,
          required int maintenanceMarginRate,
          dynamic hint}) =>
      RustLib.instance.api.parameterContractInfo(
          pairId: pairId,
          symbol: symbol,
          initialMarginRate: initialMarginRate,
          maintenanceMarginRate: maintenanceMarginRate,
          hint: hint);

  static Parameter feeAccount({required int accountId, dynamic hint}) =>
      RustLib.instance.api
          .parameterFeeAccount(accountId: accountId, hint: hint);

  static Parameter fundingInfos(
          {required List<FundingInfo> infos, dynamic hint}) =>
      RustLib.instance.api.parameterFundingInfos(infos: infos, hint: hint);

  static Parameter insuranceFundAccount(
          {required int accountId, dynamic hint}) =>
      RustLib.instance.api
          .parameterInsuranceFundAccount(accountId: accountId, hint: hint);

  static Parameter marginInfo(
          {required int marginId,
          String? symbol,
          required int tokenId,
          required int ratio,
          dynamic hint}) =>
      RustLib.instance.api.parameterMarginInfo(
          marginId: marginId,
          symbol: symbol,
          tokenId: tokenId,
          ratio: ratio,
          hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Signer>>
@sealed
class Signer extends RustOpaque {
  Signer.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Signer.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Signer,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Signer,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SignerPtr,
  );

  Contract createSignedContract({required Contract contract, dynamic hint}) =>
      RustLib.instance.api.signerCreateSignedContract(
          that: this, contract: contract, hint: hint);

  Order createSignedOrder({required Order order, dynamic hint}) =>
      RustLib.instance.api
          .signerCreateSignedOrder(that: this, order: order, hint: hint);

  static Signer ethSigner({required String ethPrivateKey, dynamic hint}) =>
      RustLib.instance.api
          .signerEthSigner(ethPrivateKey: ethPrivateKey, hint: hint);

  String signAutoDeleveraging({required AutoDeleveraging tx, dynamic hint}) =>
      RustLib.instance.api
          .signerSignAutoDeleveraging(that: this, tx: tx, hint: hint);

  String signChangePubkeyWithCreate2DataAuth(
          {required ChangePubKey tx,
          required String creatorAddress,
          required String saltArg,
          required String codeHash,
          dynamic hint}) =>
      RustLib.instance.api.signerSignChangePubkeyWithCreate2DataAuth(
          that: this,
          tx: tx,
          creatorAddress: creatorAddress,
          saltArg: saltArg,
          codeHash: codeHash,
          hint: hint);

  String signChangePubkeyWithEthEcdsaAuth(
          {required ChangePubKey tx, dynamic hint}) =>
      RustLib.instance.api.signerSignChangePubkeyWithEthEcdsaAuth(
          that: this, tx: tx, hint: hint);

  String signChangePubkeyWithOnchain(
          {required ChangePubKey tx, dynamic hint}) =>
      RustLib.instance.api
          .signerSignChangePubkeyWithOnchain(that: this, tx: tx, hint: hint);

  String signContractMatching({required ContractMatching tx, dynamic hint}) =>
      RustLib.instance.api
          .signerSignContractMatching(that: this, tx: tx, hint: hint);

  String signForcedExit({required ForcedExit tx, dynamic hint}) =>
      RustLib.instance.api.signerSignForcedExit(that: this, tx: tx, hint: hint);

  String signFunding({required Funding tx, dynamic hint}) =>
      RustLib.instance.api.signerSignFunding(that: this, tx: tx, hint: hint);

  String signLiquidation({required Liquidation tx, dynamic hint}) =>
      RustLib.instance.api
          .signerSignLiquidation(that: this, tx: tx, hint: hint);

  String signOrderMatching({required OrderMatching tx, dynamic hint}) =>
      RustLib.instance.api
          .signerSignOrderMatching(that: this, tx: tx, hint: hint);

  String signTransfer(
          {required Transfer tx,
          required String tokenSymbol,
          String? chainId,
          String? addr,
          dynamic hint}) =>
      RustLib.instance.api.signerSignTransfer(
          that: this,
          tx: tx,
          tokenSymbol: tokenSymbol,
          chainId: chainId,
          addr: addr,
          hint: hint);

  String signWithdraw(
          {required Withdraw tx,
          required String tokenSymbol,
          String? chainId,
          String? addr,
          dynamic hint}) =>
      RustLib.instance.api.signerSignWithdraw(
          that: this,
          tx: tx,
          tokenSymbol: tokenSymbol,
          chainId: chainId,
          addr: addr,
          hint: hint);

  static Signer starknetSigner(
          {required String ethPrivateKey,
          required String starknetChainId,
          required String starknetAddr,
          dynamic hint}) =>
      RustLib.instance.api.signerStarknetSigner(
          ethPrivateKey: ethPrivateKey,
          starknetChainId: starknetChainId,
          starknetAddr: starknetAddr,
          hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<SpotPriceInfo>>
@sealed
class SpotPriceInfo extends RustOpaque {
  SpotPriceInfo.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  SpotPriceInfo.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SpotPriceInfo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SpotPriceInfo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SpotPriceInfoPtr,
  );

  factory SpotPriceInfo(
          {required int tokenId, required String price, dynamic hint}) =>
      RustLib.instance.api
          .spotPriceInfoNew(tokenId: tokenId, price: price, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Transfer>>
@sealed
class Transfer extends RustOpaque {
  Transfer.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Transfer.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Transfer,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Transfer,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TransferPtr,
  );

  String getEthSignMsg({required String tokenSymbol, dynamic hint}) => RustLib
      .instance.api
      .transferGetEthSignMsg(that: this, tokenSymbol: tokenSymbol, hint: hint);

  factory Transfer(
          {required int accountId,
          required String toAddress,
          required int fromSubAccountId,
          required int toSubAccountId,
          required int token,
          required String fee,
          required String amount,
          required int nonce,
          int? ts,
          dynamic hint}) =>
      RustLib.instance.api.transferNew(
          accountId: accountId,
          toAddress: toAddress,
          fromSubAccountId: fromSubAccountId,
          toSubAccountId: toSubAccountId,
          token: token,
          fee: fee,
          amount: amount,
          nonce: nonce,
          ts: ts,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .transferSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.transferToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<UpdateGlobalVar>>
@sealed
class UpdateGlobalVar extends RustOpaque {
  UpdateGlobalVar.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  UpdateGlobalVar.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_UpdateGlobalVar,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_UpdateGlobalVar,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_UpdateGlobalVarPtr,
  );

  factory UpdateGlobalVar(
          {required int fromChainId,
          required int subAccountId,
          required Parameter parameter,
          required double serialId,
          dynamic hint}) =>
      RustLib.instance.api.updateGlobalVarNew(
          fromChainId: fromChainId,
          subAccountId: subAccountId,
          parameter: parameter,
          serialId: serialId,
          hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.updateGlobalVarToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Wallet>>
@sealed
class Wallet extends RustOpaque {
  Wallet.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Wallet.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Wallet,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Wallet,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WalletPtr,
  );

  Future<String> approveErc20(
          {required String contract,
          required String amount,
          required EthTxOption ethParams,
          dynamic hint}) =>
      RustLib.instance.api.walletApproveErc20(
          that: this,
          contract: contract,
          amount: amount,
          ethParams: ethParams,
          hint: hint);

  Future<String> depositErc20(
          {required int subAccountId,
          required String depositTo,
          required String tokenAddr,
          required String amount,
          required bool mapping,
          required EthTxOption ethParams,
          required bool isGateway,
          dynamic hint}) =>
      RustLib.instance.api.walletDepositErc20(
          that: this,
          subAccountId: subAccountId,
          depositTo: depositTo,
          tokenAddr: tokenAddr,
          amount: amount,
          mapping: mapping,
          ethParams: ethParams,
          isGateway: isGateway,
          hint: hint);

  Future<String> depositEth(
          {required int subAccountId,
          required String depositTo,
          required EthTxOption ethParams,
          required bool isGateway,
          dynamic hint}) =>
      RustLib.instance.api.walletDepositEth(
          that: this,
          subAccountId: subAccountId,
          depositTo: depositTo,
          ethParams: ethParams,
          isGateway: isGateway,
          hint: hint);

  Future<String> fullExit(
          {required int accountId,
          required int subAccountId,
          required int tokenId,
          required bool mapping,
          required EthTxOption ethParams,
          dynamic hint}) =>
      RustLib.instance.api.walletFullExit(
          that: this,
          accountId: accountId,
          subAccountId: subAccountId,
          tokenId: tokenId,
          mapping: mapping,
          ethParams: ethParams,
          hint: hint);

  Future<String> getBalance({dynamic hint}) =>
      RustLib.instance.api.walletGetBalance(that: this, hint: hint);

  Future<String> getDepositFee(
          {required EthTxOption ethParams, dynamic hint}) =>
      RustLib.instance.api
          .walletGetDepositFee(that: this, ethParams: ethParams, hint: hint);

  Future<double> getNonce({required String blockNumber, dynamic hint}) =>
      RustLib.instance.api
          .walletGetNonce(that: this, blockNumber: blockNumber, hint: hint);

  factory Wallet(
          {required String url, required String privateKey, dynamic hint}) =>
      RustLib.instance.api
          .walletNew(url: url, privateKey: privateKey, hint: hint);

  Future<String> setAuthPubkeyHash(
          {required double nonce,
          required String newPubkeyHash,
          required EthTxOption ethParams,
          dynamic hint}) =>
      RustLib.instance.api.walletSetAuthPubkeyHash(
          that: this,
          nonce: nonce,
          newPubkeyHash: newPubkeyHash,
          ethParams: ethParams,
          hint: hint);

  Future<int> waitForTransaction(
          {required String txHash, int? timeout, dynamic hint}) =>
      RustLib.instance.api.walletWaitForTransaction(
          that: this, txHash: txHash, timeout: timeout, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<Withdraw>>
@sealed
class Withdraw extends RustOpaque {
  Withdraw.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Withdraw.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Withdraw,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Withdraw,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WithdrawPtr,
  );

  String getEthSignMsg({required String tokenSymbol, dynamic hint}) => RustLib
      .instance.api
      .withdrawGetEthSignMsg(that: this, tokenSymbol: tokenSymbol, hint: hint);

  factory Withdraw(
          {required int accountId,
          required int subAccountId,
          required int toChainId,
          required String toAddress,
          required int l2SourceToken,
          required int l1TargetToken,
          required String amount,
          String? callData,
          required String fee,
          required int nonce,
          required bool withdrawToL1,
          required int withdrawFeeRatio,
          int? ts,
          dynamic hint}) =>
      RustLib.instance.api.withdrawNew(
          accountId: accountId,
          subAccountId: subAccountId,
          toChainId: toChainId,
          toAddress: toAddress,
          l2SourceToken: l2SourceToken,
          l1TargetToken: l1TargetToken,
          amount: amount,
          callData: callData,
          fee: fee,
          nonce: nonce,
          withdrawToL1: withdrawToL1,
          withdrawFeeRatio: withdrawFeeRatio,
          ts: ts,
          hint: hint);

  void sign({required ZkLinkSigner zkLinkSigner, dynamic hint}) =>
      RustLib.instance.api
          .withdrawSign(that: this, zkLinkSigner: zkLinkSigner, hint: hint);

  String toJson({dynamic hint}) =>
      RustLib.instance.api.withdrawToJson(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<ZkLinkSignature>>
@sealed
class ZkLinkSignature extends RustOpaque {
  ZkLinkSignature.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ZkLinkSignature.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ZkLinkSignature,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ZkLinkSignature,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ZkLinkSignaturePtr,
  );

  String getPubkey({dynamic hint}) =>
      RustLib.instance.api.zkLinkSignatureGetPubkey(that: this, hint: hint);

  String getSignature({dynamic hint}) =>
      RustLib.instance.api.zkLinkSignatureGetSignature(that: this, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<ZkLinkSigner>>
@sealed
class ZkLinkSigner extends RustOpaque {
  ZkLinkSigner.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ZkLinkSigner.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ZkLinkSigner,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ZkLinkSigner,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ZkLinkSignerPtr,
  );

  static ZkLinkSigner ethSig({required String sig, dynamic hint}) =>
      RustLib.instance.api.zkLinkSignerEthSig(sig: sig, hint: hint);

  String getPubkey({dynamic hint}) =>
      RustLib.instance.api.zkLinkSignerGetPubkey(that: this, hint: hint);

  String getPubkeyHash({dynamic hint}) =>
      RustLib.instance.api.zkLinkSignerGetPubkeyHash(that: this, hint: hint);

  ZkLinkSignature signMusig({required List<int> msg, dynamic hint}) =>
      RustLib.instance.api
          .zkLinkSignerSignMusig(that: this, msg: msg, hint: hint);

  static ZkLinkSigner starknetSig({required String sig, dynamic hint}) =>
      RustLib.instance.api.zkLinkSignerStarknetSig(sig: sig, hint: hint);
}
